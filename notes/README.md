Оптимизации бинпоиска, фенвика, проверки на простоту,  и тд и тп
## Проверка на простоту
Вместо
```cpp
for (int i = 2; i * i <= n; i++) {
  if (n % i == 0) return false;
}
```

Пойдём только по нечётным
```cpp
if (n % 2 == 0) return false;
for (int i = 3; i * i <= n; i += 2) {
  if (n % i == 0) return false;
}
```

Далее обощается, если взять несколько первых простых и рассматривать только числа, взаимнопростые с ними:
prime_cnt | prime_prod | coeff
-+-+-
n = 1 | 2 | 2
n = 2 | 6 | 3
n = 3 | 30 | 3.75
n = 4 | 210 | 4.375
n = 5 | 1890 | 4.375
n = 6 | 20790 | 4.8125
n = 7 | 270270 | 5.21354
n = 8 | 4594590 | 5.53939

## Двоичная куча
Задача про удаление из кучи элемента, которого в куче нет

## Биномиальная куча
Попробуйте с помощью аналогичной идеи поддерживать упорядоченное множество
(Т.е. поддерживать операции, разрешённые в set / map)

## Оптимизация бинподъёмов
Пусть ответ находится при подёме на K элементов, максимальная высота подъёма - N

За сколько операций можем отвечать на запрос?
- logN
- 2 * logK
- loglogN + logK
- 2loglogK + logK

## СНМ (случайные приоритеты)
- СНМ со случайными приоритетами работает за O(logN) на запрос

## Многомерное дерево Фенвика
Оптимизация на 20-40% в двумерном случае, если храним вершины в хештаблице (std::unordered_map):
Идея: половина из всех отрезков разбиения запроса - размером > sqrtN и находятся в "верхней половине" дерева Фенвика
Давайте хранить эту верхушку дерева в честном двумерном массиве, сколько нам позволяет ML (Memory Limit), а при обращении к этим элементам будем смотреть в массив вместо unordered_map
Т.к. константа при обращении к массиву меньше в более чем 2 раза по отношению к хештаблице - мы выиграем некоторое время.
